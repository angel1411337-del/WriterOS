/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => WriterOSPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");
var import_child_process = require("child_process");
var path = __toESM(require("path"));
var fs = __toESM(require("fs"));

// views/ChatView.ts
var import_obsidian = require("obsidian");
var VIEW_TYPE_CHAT = "writeros-chat-view";
var ChatView = class extends import_obsidian.ItemView {
  constructor(leaf, apiClient, vaultId) {
    super(leaf);
    this.apiClient = apiClient;
    this.vaultId = vaultId;
  }
  getViewType() {
    return VIEW_TYPE_CHAT;
  }
  getDisplayText() {
    return "WriterOS Chat";
  }
  getIcon() {
    return "message-square";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("writeros-chat-container");
    const header = container.createEl("div", { cls: "writeros-chat-header" });
    header.createEl("h4", { text: "WriterOS Agent" });
    this.messagesContainer = container.createEl("div", { cls: "writeros-chat-messages" });
    this.addMessage("system", "Hello! I am your WriterOS assistant. How can I help you with your story today?");
    const inputContainer = container.createEl("div", { cls: "writeros-chat-input-container" });
    this.inputEl = inputContainer.createEl("textarea", {
      cls: "writeros-chat-input",
      attr: { placeholder: "Ask about your characters, plot, or world..." }
    });
    this.inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        this.sendMessage();
      }
    });
    const sendBtn = inputContainer.createEl("button", {
      cls: "writeros-chat-send-btn",
      text: "Send"
    });
    sendBtn.addEventListener("click", () => this.sendMessage());
  }
  async sendMessage() {
    const message = this.inputEl.value.trim();
    if (!message) return;
    this.inputEl.value = "";
    this.addMessage("user", message);
    const assistantMsgEl = this.addMessage("assistant", "");
    const contentEl = assistantMsgEl.querySelector(".writeros-message-content");
    contentEl.setText("Thinking...");
    let fullResponse = "";
    let isFirstChunk = true;
    await this.apiClient.streamChat(
      message,
      this.vaultId,
      (chunk) => {
        if (isFirstChunk) {
          contentEl.setText("");
          isFirstChunk = false;
        }
        fullResponse += chunk;
        contentEl.setText(fullResponse);
        this.scrollToBottom();
      },
      (error) => {
        new import_obsidian.Notice(error);
        contentEl.setText(`Error: ${error}`);
      },
      () => {
        console.log("Stream complete");
      }
    );
  }
  addMessage(role, text) {
    const msgEl = this.messagesContainer.createEl("div", {
      cls: `writeros-message writeros-message-${role}`
    });
    const contentEl = msgEl.createEl("div", { cls: "writeros-message-content" });
    contentEl.setText(text);
    this.scrollToBottom();
    return msgEl;
  }
  scrollToBottom() {
    this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
  }
  async onClose() {
  }
};

// api.ts
var ApiClient = class {
  constructor(port = 8e3) {
    this.baseUrl = `http://localhost:${port}`;
  }
  async checkHealth() {
    try {
      const response = await fetch(`${this.baseUrl}/health`);
      return response.ok;
    } catch (e) {
      return false;
    }
  }
  async analyzeVault(vaultPath, vaultId) {
    try {
      const response = await fetch(`${this.baseUrl}/analyze`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ vault_path: vaultPath, vault_id: vaultId })
      });
      return response.ok;
    } catch (e) {
      console.error("Analysis failed", e);
      return false;
    }
  }
  async streamChat(message, vaultId, onChunk, onError, onDone) {
    var _a;
    try {
      const response = await fetch(`${this.baseUrl}/chat/stream`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ message, vault_id: vaultId })
      });
      if (!response.ok) {
        onError(`Server error: ${response.statusText}`);
        return;
      }
      const reader = (_a = response.body) == null ? void 0 : _a.getReader();
      const decoder = new TextDecoder();
      if (!reader) {
        onError("Failed to read response stream");
        return;
      }
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        const chunk = decoder.decode(value);
        const lines = chunk.split("\n");
        for (const line of lines) {
          if (line.startsWith("data: ")) {
            const dataStr = line.slice(6);
            if (dataStr === "[DONE]") {
              onDone();
              return;
            }
            try {
              const data = JSON.parse(dataStr);
              if (data.content) {
                onChunk(data.content);
              } else if (data.error) {
                onError(data.error);
              }
            } catch (e) {
              console.warn("Failed to parse SSE data", e);
            }
          }
        }
      }
    } catch (e) {
      onError(String(e));
    }
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  pythonPath: "python",
  scriptPath: "",
  serverPath: "",
  defaultGraphType: "force",
  serverPort: 8e3
};
var WriterOSPlugin = class extends import_obsidian2.Plugin {
  async onload() {
    await this.loadSettings();
    this.apiClient = new ApiClient(this.settings.serverPort);
    this.vaultId = this.getOrCreateVaultId();
    this.registerView(
      VIEW_TYPE_CHAT,
      (leaf) => new ChatView(leaf, this.apiClient, this.vaultId)
    );
    this.addRibbonIcon("dice", "WriterOS Graph", (evt) => {
      this.generateGraph(this.settings.defaultGraphType);
    });
    this.addRibbonIcon("message-square", "WriterOS Chat", (evt) => {
      this.activateChatView();
    });
    const statusBarItemEl = this.addStatusBarItem();
    this.checkServerStatus(statusBarItemEl);
    this.addCommand({
      id: "open-writeros-chat",
      name: "Open Chat",
      callback: () => this.activateChatView()
    });
    this.addCommand({
      id: "analyze-vault",
      name: "Analyze Vault",
      callback: () => this.analyzeVault()
    });
    this.addCommand({
      id: "start-writeros-server",
      name: "Start Server",
      callback: () => this.startServer()
    });
    ["force", "family", "faction", "location"].forEach((type) => {
      this.addCommand({
        id: `open-${type}-graph`,
        name: `Open ${type.charAt(0).toUpperCase() + type.slice(1)} Graph`,
        callback: () => this.generateGraph(type)
      });
    });
    this.addSettingTab(new WriterOSSettingTab(this.app, this));
  }
  async checkServerStatus(statusBar) {
    const isRunning = await this.apiClient.checkHealth();
    if (isRunning) {
      statusBar.setText("WriterOS: Connected");
      statusBar.style.color = "lightgreen";
    } else {
      statusBar.setText("WriterOS: Disconnected");
      statusBar.style.color = "orange";
      new import_obsidian2.Notice('WriterOS Server not running. Use "Start Server" command.');
    }
  }
  async startServer() {
    const pythonPath = this.settings.pythonPath;
    const serverPath = this.settings.serverPath || path.join(this.getVaultPath(), "server.py");
    if (!fs.existsSync(serverPath)) {
      new import_obsidian2.Notice(`Server script not found at: ${serverPath}`);
      return;
    }
    new import_obsidian2.Notice("Starting WriterOS Server...");
    const subprocess = (0, import_child_process.spawn)(pythonPath, [serverPath], {
      detached: true,
      stdio: "ignore"
    });
    subprocess.unref();
    setTimeout(async () => {
      const isRunning = await this.apiClient.checkHealth();
      if (isRunning) {
        new import_obsidian2.Notice("WriterOS Server Started!");
      } else {
        new import_obsidian2.Notice("Failed to connect to server. Check console.");
      }
    }, 3e3);
  }
  async analyzeVault() {
    new import_obsidian2.Notice("Starting Vault Analysis...");
    const success = await this.apiClient.analyzeVault(this.getVaultPath(), this.vaultId);
    if (success) {
      new import_obsidian2.Notice("Analysis started in background.");
    } else {
      new import_obsidian2.Notice("Failed to start analysis. Is server running?");
    }
  }
  async activateChatView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_CHAT);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      await leaf.setViewState({ type: VIEW_TYPE_CHAT, active: true });
    }
    workspace.revealLeaf(leaf);
  }
  getVaultPath() {
    return this.app.vault.adapter.getBasePath();
  }
  getOrCreateVaultId() {
    const vaultPath = this.getVaultPath();
    const configPath = path.join(vaultPath, ".writeros", "config.json");
    if (fs.existsSync(configPath)) {
      try {
        const config = JSON.parse(fs.readFileSync(configPath, "utf-8"));
        return config.vault_id;
      } catch (e) {
        console.error("Failed to read config", e);
      }
    }
    const writerOSPath = path.join(vaultPath, ".writeros");
    if (!fs.existsSync(writerOSPath)) {
      fs.mkdirSync(writerOSPath, { recursive: true });
    }
    const uuid = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
      var r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
    fs.writeFileSync(configPath, JSON.stringify({
      vault_id: uuid,
      created_at: (/* @__PURE__ */ new Date()).toISOString()
    }, null, 2));
    return uuid;
  }
  async generateGraph(type) {
    new import_obsidian2.Notice(`Generating ${type} graph...`);
    const vaultPath = this.getVaultPath();
    const pythonPath = this.settings.pythonPath;
    const scriptPath = this.settings.scriptPath || path.join(vaultPath, "generate_graph.py");
    const command = `"${pythonPath}" "${scriptPath}" --vault-path "${vaultPath}" --graph-type "${type}" --vault-id "${this.vaultId}"`;
    (0, import_child_process.exec)(command, (error, stdout, stderr) => {
      if (error) {
        console.error(`exec error: ${error}`);
        new import_obsidian2.Notice(`Error: ${error.message}`);
        return;
      }
      const match = stdout.match(/Graph HTML generated: (.*)/);
      if (match && match[1]) {
        const filePath = match[1].trim();
        this.openGraphInBrowser(filePath);
      } else {
        const lines = stdout.trim().split("\n");
        const lastLine = lines[lines.length - 1];
        if (lastLine && lastLine.endsWith(".html")) {
          this.openGraphInBrowser(lastLine.trim());
        } else {
          new import_obsidian2.Notice("Graph generated but could not auto-open. Check .writeros/graphs/ folder.");
        }
      }
    });
  }
  openGraphInBrowser(filePath) {
    if (process.platform === "win32") {
      (0, import_child_process.exec)(`powershell -Command "Start-Process '${filePath}'"`, (error) => {
        if (error) {
          console.error("Failed to open graph:", error);
          new import_obsidian2.Notice(`Graph saved to: ${filePath}`);
        }
      });
    } else if (process.platform === "darwin") {
      (0, import_child_process.exec)(`open "${filePath}"`);
    } else {
      (0, import_child_process.exec)(`xdg-open "${filePath}"`);
    }
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var WriterOSSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "WriterOS Settings" });
    new import_obsidian2.Setting(containerEl).setName("Python Path").setDesc("Path to Python executable").addText((text) => text.setPlaceholder("python").setValue(this.plugin.settings.pythonPath).onChange(async (value) => {
      this.plugin.settings.pythonPath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Script Path").setDesc("Path to generate_graph.py").addText((text) => text.setPlaceholder("Path to generate_graph.py").setValue(this.plugin.settings.scriptPath).onChange(async (value) => {
      this.plugin.settings.scriptPath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Server Script Path").setDesc("Path to server.py (Optional, defaults to vault root)").addText((text) => text.setValue(this.plugin.settings.serverPath).onChange(async (value) => {
      this.plugin.settings.serverPath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Server Port").setDesc("Port for FastAPI server").addText((text) => text.setValue(String(this.plugin.settings.serverPort)).onChange(async (value) => {
      this.plugin.settings.serverPort = parseInt(value) || 8e3;
      await this.plugin.saveSettings();
    }));
  }
};
